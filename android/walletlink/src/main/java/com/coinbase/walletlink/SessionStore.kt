package com.coinbase.walletlink

import com.coinbase.wallet.store.interfaces.StoreInterface
import com.coinbase.walletlink.models.Session
import com.coinbase.walletlink.models.old.StoreKeys
import io.reactivex.Observable
import java.net.URL
import java.util.concurrent.locks.ReentrantLock
import kotlin.concurrent.withLock

class SessionStore(private val store: StoreInterface) {
    private val accessLock = ReentrantLock()

    /**
     * Get stored sessions
     */
    val sessions: List<Session> get() = getStoredSessions()

    /**
    * Get stored sessions filtered by url
    *
    * @param url URL to filter sessions
    *
    * @return Sessions for given URL
    */
    fun getSessions(url: URL): List<Session> {
        return getStoredSessions().filter { it.rpcUrl == url }
    }

    /**
    * Get stored session for given sessionID and rpc URL
    *
    * @param id Session ID
    * @param url URL to filter sessions
    *
    * @returns Sessions for given URL
    */
    fun getSession(id: String, url: URL): Session? {
        return getStoredSessions().first { it.rpcUrl == url && it.id == id }
    }

    /**
     * Store session/secret to shared preferences using Android KeyStore
     *
     * @param rpcUrl WalletLink server websocket URL
     * @param sessionId Session ID generated by the host
     * @param secret Secret generated by the host
     */
    fun save(rpcUrl: URL, sessionId: String, secret: String) {
        accessLock.withLock {
            val sessions = (store.get(StoreKeys.sessions) ?: arrayOf())
                .filter { it.id != sessionId && it.rpcUrl == rpcUrl }.toMutableList()

            sessions.add(Session(id = sessionId, secret = secret, rpcUrl = rpcUrl))

            store.set(StoreKeys.sessions, sessions.toTypedArray())
        }
    }

    /**
     * Deletes sessionID from keychain
     *
     * @param sessionId Session ID generated by the host
     */
    fun delete(sessionId: String) {
        accessQueue.withLock {
            val sessionIds = (store.get(StoreKeys.sessions) ?: arrayOf()).filter { it != sessionId }.toMutableList()

            store.set(StoreKeys.secret(sessionId), null)
            store.set(StoreKeys.sessions, sessionIds.toTypedArray())
        }
    }

    // / Observe for distinct stored sessionIds update
    fun observeSessions(): Observable<Array<String>> {
        return store.observe(StoreKeys.sessions).map { it.element ?: arrayOf() }.distinctUntilChanged()
    }

    // Private helpers

    private fun getStoredSessions(): List<Session> {
        var result = listOf<Session>()

        accessQueue.withLock {
            val sessionIds = store.get(StoreKeys.sessions) ?: arrayOf()
            result = sessionIds.mapNotNull { sessionId ->
                val secretStoreKey = StoreKeys.secret(sessionId)
                val secret = store.get(secretStoreKey) ?: return@mapNotNull null

                return@mapNotNull Session(sessionId, secret)
            }
        }

        return result
    }
}
