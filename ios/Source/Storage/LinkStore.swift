// Copyright (c) 2017-2019 Coinbase Inc. See LICENSE

import CBStore

/// Persist session secrets
final class LinkStore {
    private let accessQueue = DispatchQueue(label: "WalletLink.LinkStore.accessQueue")
    private let store: StoreProtocol

    required init(store: StoreProtocol = Store()) {
        self.store = store
    }

    /// Get stored sessions
    var sessions: [Session] {
        return getStoredSessions()
    }

    /// Store session/secret to keychain
    ///
    /// - Parameters:
    ///     - sessionId: Session ID generated by the host
    ///     - secret: Secret generated by the host
    func save(sessionId: String, secret: String) {
        accessQueue.sync {
            var sessions = self.store.get(.sessions)?.filter { $0 != sessionId } ?? []

            sessions.append(sessionId)
            self.store.set(.secret(for: sessionId), value: secret)
            self.store.set(.sessions, value: sessions)
        }
    }

    /// Deletes sessionId from keychain
    ///
    /// - Parameters:
    ///     - sessionId: Session ID generated by the host
    func delete(sessionId: String) {
        accessQueue.sync {
            let sessions = self.store.get(.sessions)?.filter { $0 != sessionId } ?? []

            self.store.set(.secret(for: sessionId), value: nil)
            self.store.set(.sessions, value: sessions)
        }
    }

    // MARK: - Private helpers

    private func getStoredSessions() -> [Session] {
        var result: [Session]!

        accessQueue.sync {
            let sessionIds = self.store.get(.sessions) ?? []
            result = sessionIds.compactMap { sessionId in
                let secretStoreKey = StoreKeys.secret(for: sessionId)

                guard let secret = self.store.get(secretStoreKey) else { return nil }

                return Session(sessionId: sessionId, secret: secret)
            }
        }

        return result
    }
}
